#+TITLE: TLS certificates

Objectives:
- Generate a CA certificate =qvm-ca.pem= used to sign server certificates for each VM.
  - Store certificate and private key in =QVM_DIR/certs/ca=
- Generate VM server certificates in =QVM_DIR/certs/hosts=
- Install certificates at =/root/cert= in each VM
- Ponder about how to automate this step, perhaps with =cloud-init=

The following should work:
#+begin_src sh
  curl --cacert="${QVM_DIR}/ca-cert/qvm-ca.pem" https://cp.qvm0.lan
  export SSL_CERT_DIR="${QVM_DIR}"/ca-cert
  curl https://cp.qvm0.lan
#+end_src


** Create a keypair for the =qvm= certificate authority

#+begin_src sh :tangle gen-ca-keypair.sh
  args=(
    -out "${QVM_DIR}/certs/ca/priv.pem"
    -outpubkey "${QVM_DIR}/certs/ca/pub.pem"
    -outform PEM
    -algorithm RSA
    -pkeyopt rsa_keygen_bits:2048
  )
  openssl genpkey "${args[@]}"
#+end_src

To peruse the generated keys:
#+begin_src sh
  openssl pkey -in "${QVM_DIR}/certs/ca/priv.pem" -text -noout
  openssl pkey -in "${QVM_DIR}/certs/ca/pub.pem" -pubin -text -noout
#+end_src

Note that all the information is contained in the private key.

** Create a self-signed CA certificate

#+begin_src sh :tangle gen-ca-cert.sh
  args=(
    -x509
    -key "${QVM_DIR}/certs/ca/priv.pem"
    -subj "/CN=QVM"
    -days 365
    -out "${QVM_DIR}/certs/ca/cert.pem"
  )
  openssl req "${args[@]}"
#+end_src

To examine the generated certificate:
#+begin_src sh
  openssl x509 -in "${QVM_DIR}"/certs/ca/cert.pem -text -noout
#+end_src

** Create a certificate for =cp=

We create a certificate for =cp.qvm0.lan= signed by our =QVM= certificate authority,
in one step.

A more step-by-step alternative,
reflecting the real certificate issuance process,
would be to first create a certificate request,
and then convert it to a x509 certificate (acting as a "micro-CA" in openssl parlance).


#+begin_src sh :tangle gen-server-cert.sh
  args=(
    -batch # Non-interactive mode
    -x509  # Output a certificate directly, rather than a request
    -out "${QVM_DIR}/certs/hosts/cp/server.pem" # The generated certificate file
    -newkey rsa:2048 # Generate the certified keypair
    -keyout "${QVM_DIR}/certs/hosts/cp/priv.pem" # Generated private key
    -noenc # Do not encrypt the private key
    -subj "/CN=cp.qvm0.lan" # The identity bound by the certificate to the keypair
    -addext "subjectAltName = DNS:cp.qvm0, DNS:cp.qvm0.lan" # Some flexibility for the valid domain names
    -addext "extendedKeyUsage=critical,serverAuth"
    -addext "basicConstraints = critical, CA:false"
    -days 365
    # Our QVM certificate authority
    -CA "${QVM_DIR}/certs/ca/cert.pem"
    -CAkey "${QVM_DIR}/certs/ca/priv.pem"
  )

  openssl req "${args[@]}"
#+end_src

To examine the generated cert:

#+begin_src sh
  openssl x509 -in "${QVM_DIR}/certs/hosts/cp/server.pem" -text -noout
  # Check the SubjectAltName extensions that gives us hostname flexibility
  openssl x509 -in "${QVM_DIR}/certs/hosts/cp/server.pem" -ext subjectAltName -noout
#+end_src


** Testing the certificate
- Copy the certificate to the =cp= VM

#+begin_src sh :tangle install-server-cert.sh
  #!/bin/bash
  guest="${1:-cp}"
  cert_dir=/root/cert
  # Ensure target directory exists

  ssh -F "${QVM_DIR}/ssh/config" "root@${guest}.qvm0.lan" mkdir -p "${cert_dir}"

  args=(
    -F "${QVM_DIR}/ssh/config"
    # Sources
    "${QVM_DIR}/certs/hosts/${guest}/"{server,priv}.pem
    # Dest
    "root@${guest}.qvm0.lan:${cert_dir}"
  )

  scp "${args[@]}"
#+end_src

- Start an HTTPS-capable web server on the =cp= guest, and point it to the server certificate
- Point =curl= at the root CA certificate on the host, and issue an HTTPS request:

#+begin_src sh
  curl --cacert "${QVM_DIR}/certs/ca/cert.pem" https://cp.qvm0.lan
#+end_src

Some questions that come to mind before setting out:
- What is the simplest toy server setup available to use on the RHEL10 =cp= guest ?
- Is there a standard location where to put server certificates ?
- Is there a standard way to instruct an HTTP daemon to use TLS with a given cert ?
